table FactHICP_Rates_YoY
	lineageTag: c5ee174b-28a8-4da7-b074-b6c84f4b844b

	column time
		dataType: string
		lineageTag: 1b76cfff-c59c-4ff1-9faa-bceb513846d9
		summarizeBy: none
		sourceColumn: time

		annotation SummarizationSetBy = Automatic

	column geo
		dataType: string
		lineageTag: 6d007be7-e8d8-4c29-aaa7-f418d8edb132
		summarizeBy: none
		sourceColumn: geo

		annotation SummarizationSetBy = Automatic

	column coicop
		dataType: string
		lineageTag: 9e4a69c9-822e-4231-994f-2bdf17443c79
		summarizeBy: none
		sourceColumn: coicop

		annotation SummarizationSetBy = Automatic

	column unit
		dataType: string
		lineageTag: 3c9aff27-beec-405c-b205-75e95a1c4c21
		summarizeBy: none
		sourceColumn: unit

		annotation SummarizationSetBy = Automatic

	column value
		dataType: double
		lineageTag: fb7ee90e-dda1-42a3-a3fc-11b3d36518c8
		summarizeBy: sum
		sourceColumn: value

		annotation SummarizationSetBy = Automatic

		annotation PBI_FormatHint = {"isGeneralNumber":true}

	column Date
		dataType: dateTime
		formatString: Long Date
		lineageTag: 56d8b63a-6458-4ca7-b153-8aa59ff2b7aa
		summarizeBy: none
		sourceColumn: Date

		annotation SummarizationSetBy = Automatic

		annotation UnderlyingDateTimeDataType = Date

	partition FactHICP_Rates_YoY = m
		mode: import
		source =
				let
				  Load = (dataset as text, unitCode as text, coicops as list, geos as list, startMonth as text, endMonth as text) as table =>
				  let
				      Base="https://ec.europa.eu/eurostat/api/dissemination/statistics/1.0/data/",
				      Parts=List.Combine({{"lang=EN","freq=M","unit=" & unitCode,"sinceTimePeriod=" & startMonth,"untilTimePeriod=" & endMonth},
				                          List.Transform(coicops, each "coicop=" & _),
				                          List.Transform(geos,    each "geo="    & _)}),
				      Url = Base & dataset & "?" & Text.Combine(Parts,"&"),
				      Raw = Web.Contents(Url, [Timeout=#duration(0,0,90,0), Headers=[Accept="application/json"]]),
				      J   = Json.Document(Raw),
				      D   = if Record.HasFields(J,"dataset") then J[dataset] else J,
				
				      Ids  = List.Transform(D[id], each Text.Lower(Text.From(_))),
				      DimR = Record.FromList(Record.FieldValues(D[dimension]),
				                              List.Transform(Record.FieldNames(D[dimension]), Text.Lower)),
				      GetCodes = (dimname as text) as list =>
				        let d = Record.Field(DimR, dimname),
				            cat = d[category],
				            idx = try cat[index] otherwise null
				        in  if idx <> null then
				              if Value.Is(cat[index], type list) then List.Transform(cat[index], each Text.From(_))
				              else if Value.Is(cat[index], type record)
				                   then List.Transform(Table.Sort(Record.ToTable(cat[index]),{{"Value",Order.Ascending}})[Name], each Text.From(_))
				                   else Record.FieldNames(cat[label])
				            else if Record.HasFields(cat,"label") then Record.FieldNames(cat[label]) else {},
				
				      Codes  = List.Transform(Ids, each GetCodes(_)),
				      Sizes  = List.Transform(Codes, each List.Count(_)),
				      Mdim   = List.Count(Sizes),
				      N      = if Mdim=0 then 0 else List.Product(Sizes),
				
				      ValRaw = D[value],
				      Values =
				        if Value.Is(ValRaw, type list) then ValRaw
				        else if Value.Is(ValRaw, type record) then
				            let names=Record.FieldNames(ValRaw), vals=Record.FieldValues(ValRaw),
				                pos=List.Transform(names, each Number.FromText(_)),
				                base=List.Repeat({null}, N),
				                z=List.Zip({pos,vals})
				            in  List.Accumulate(z, base, (st,p)=> List.ReplaceRange(st,p{0},1,{p{1}}))
				        else List.Repeat({null}, N),
				
				      Result =
				        if N=0 then #table(Ids & {"value"}, {})
				        else
				          let idxs={0..N-1},
				              rad = List.Transform({0..Mdim-1}, each if _=Mdim-1 then 1 else List.Product(List.Range(Sizes,_+1,Mdim-(_+1)))),
				              DimCol=(k as number)=> let sz=Sizes{k}, r=rad{k}, c=Codes{k} in List.Transform(idxs,(i)=> c{ Number.Mod(Number.IntegerDivide(i,r), sz)}),
				              Tbl = Table.FromColumns(List.Transform({0..Mdim-1}, each DimCol(_)) & {Values}, Ids & {"value"})
				          in  Tbl,
				
				      Lower = Table.TransformColumnNames(Result, Text.Lower),
				      Norm  = if List.Contains(Table.ColumnNames(Lower),"time_period") then Table.RenameColumns(Lower,{{"time_period","time"}}) else Lower,
				      Keep  = Table.SelectColumns(Norm, {"time","geo","coicop","unit","value"}, MissingField.Ignore),
				      Typed = Table.TransformColumnTypes(Keep, {{"time", type text},{"geo", type text},{"coicop", type text},{"unit", type text},{"value", type number}}, "en-US"),
				      AddDate = Table.AddColumn(Typed, "Date", each Date.FromText([time] & "-01")),
				      ForceTypes = Table.TransformColumnTypes(AddDate, {{"Date", type date}})
				  in
				      ForceTypes,
				
				  // YoY for CP00 only, % -> decimal
				  RawYoY = Load("prc_hicp_manr", "RCH_A", {"CP00"}, pGeos, pStartMonth, pEndMonth),
				  YoY    = Table.TransformColumns(RawYoY, {{"value", each _ / 100.0, type number}})
				in
				  YoY

	annotation PBI_NavigationStepName = Navigation

	annotation PBI_ResultType = Table

